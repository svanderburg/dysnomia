#!/bin/bash
set -e
set -o pipefail

# Copyright (c) 2009-2016 Sander van der Burg
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# Creates an unprivileged group and/or user
#
# Environment variables:
# container_group: Name of the group to create. If empty, no group will be created.
# container_gid: GID of the group to create. If empty, an aribitrary one will be chosen.
# container_username: Name of the user to create. If empty, no user will be created.
# container_uid: UID of the user to create. If empty, an aribitrary one will be chosen.
# container_homeDir: Path to the home directory of the user
# container_createHomeDir: When set to 1 the home directory will be created if it does not exists
# container_shell: Path to the shell of the user

createUnprivilegedUserAndGroup()
{
    # Create unprivileged group that runs the process, if requested
    if [ "$container_group" != "" ]
    then
        params=""
        
        if [ "$container_gid" != "" ]
        then
            params="$params -g $container_gid"
        fi
        
        params="$params $container_group"
        
        if ! getent group $container_group
        then
            groupadd $params
        fi
    fi
    
    # Create unprivileged user that runs the process, if requested
    if [ "$container_username" != "" ]
    then
        params=""
        
        if [ "$container_uid" != "" ]
        then
            params="$params -u $container_uid"
        fi
        
        if [ "$container_group" != "" ]
        then
            params="$params -g $container_group"
        fi
        
        if [ "$container_homeDir" = "" ]
        then
            params="$params -d /dev/null"
        else
            params="$params -d $container_homeDir"
        fi
        
        if [ "$container_createHomeDir" != "" ]
        then
            params="$params -m"
        fi
        
        if [ "$container_shell" = "" ]
        then
            params="$params -s /bin/sh"
        else
            params="$params -s $container_shell"
        fi
        
        params="$params $container_username"
        
        if ! id -u $container_username
        then
            useradd $params
        fi
    fi
}

# Removes an unpriveleged group or user.
#
# Environment variables:
# container_group: Name of the group to delete. If empty no group will be deleted.
# container_username: Name of the user to delete. If empty, no user will be deleted.

removeUnprivilegedUserAndGroup()
{
    # Remove unprivileged user, if requested
    
    if [ "$container_username" != "" ]
    then
        if id -u $container_username
        then
            userdel $container_username
        fi
    fi
    
    # Remove unprivileged group, if requested
    
    if [ "$container_group" != "" ]
    then
        if getent group $container_group
        then
            groupdel $container_group
        fi
    fi
}

# Adds user credentials to a systemd job
#
# Environment variables:
# container_group: Name of the group to run under. If empty no group restrictions will be applied.
# container_username: Name of the user to run under. If empty, no user restrictions will be applied.

addUserSettingsToSystemdConfig()
{
    if [ "$container_group" != "" ]
    then
        echo "Group=$container_group" >> $1
    fi
    
    if [ "$container_username" != "" ]
    then
        echo "User=$container_username" >> $1
    fi
}

# Checks whether DYSNOMIA_CONTAINERS_PATH variables is set. If not set, it
# configures a default value

checkContainersPath()
{
    if [ "$DYSNOMIA_CONTAINERS_PATH" = "" ]
    then
        DYSNOMIA_CONTAINERS_PATH=/etc/dysnomia/containers
    fi
}

# Checks whether DYSNOMIA_COMPONENTS_PATH variables is set. If not set, it
# configures a default value

checkComponentsPath()
{
    if [ "$DYSNOMIA_COMPONENTS_PATH" = "" ]
    then
        DYSNOMIA_COMPONENTS_PATH=/etc/dysnomia/components
    fi
}

# Checks whether DYSNOMIA_STATEDIR environment variable is set. If not set, it
# configures a default value

checkStateDir()
{
    if [ "$DYSNOMIA_STATEDIR" = "" ]
    then
        DYSNOMIA_STATEDIR="/var/state/dysnomia"
    fi
}

# Determines the name of the component from a given path. If a Nix store path is
# given, then the hash prefix is stripped from it.
#
# Parameters:
# $1: Path or name of a component
# 
# Environment variables:
# componentName: will be set to the name of the component

determineComponentName()
{
    componentName=$(basename "$1")
    storePrefix="${NIX_STORE_DIR:-/nix/store}/"

    if [ "${1:0:${#storePrefix}}" = "$storePrefix" ]
    then
        componentName="${componentName:33}"
    fi
}

# Determines the type identifier of a given path
#
# Parameters:
# $1: Path to a container
# 
# Environment variables:
# typeIdentifier: Will be set to the name of the type

determineTypeIdentifier()
{
    typeIdentifier=$(basename "$1")
}

# Determines the name of the container. If a Nix store path is given, then the
# hash prefix is stripped from it. If no parameter is given then the container
# name reverts to its type identifier.
#
# Parameters:
# $1: Path or name of a container
#
# Environment variables:
# typeIdentifier: Type of the mutable component that determines the plugin that communicates with it
# containerName: will be set to the name of the container

determineContainerName()
{
    if [ "$1" = "" ]
    then
        containerName=$typeIdentifier
    else
        containerName=$(basename "$1")
        
        storePrefix="${NIX_STORE_DIR:-/nix/store}/"

        if [ "${1:0:${#storePrefix}}" = "$storePrefix" ]
        then
            containerName="${containerName:33}"
        fi
    fi
}

# Marks a component as activated in a container so that it will not be deleted by
# the garbage collector
#
# Environment variables:
# DYSNOMIA_STATEDIR: Path where Dysnomia stores state
# containerName: Name of the container in which the mutable component is hosted
# componentName: Name of the component
# activatedPath: Path to the directory that stores which components have been activated in it

markComponentAsActive()
{
    mkdir -p $DYSNOMIA_STATEDIR/activated/$containerName
    
    if [ -f $DYSNOMIA_STATEDIR/garbage/$containerName/$componentName ]
    then
        mv $DYSNOMIA_STATEDIR/garbage/$containerName/$componentName $DYSNOMIA_STATEDIR/activated/$containerName/$componentName
    else
        touch $DYSNOMIA_STATEDIR/activated/$containerName/$componentName
    fi
}

# Unmarks a component as activated in a container so that it will be reported as
# such
#
# Environment variables:
# containerName: Name of the container in which the mutable component is hosted
# activatedPath: Path to the directory that stores which components have been activated in it

unmarkComponentAsActive()
{
    rm -f $DYSNOMIA_STATEDIR/activated/$containerName/$componentName
}

# Marks a component that has previously been activated as a garbage so that it
# will be deleted by the garbage collector,
#
# Environment variables:
# containerName: Name of the container in which the mutable component is hosted
# activatedPath: Path to the directory that stores which components have been activated in it
# garbagePath: Path to the directory that stores which components have been marked as garbage

markComponentAsGarbage()
{
    mkdir -p $DYSNOMIA_STATEDIR/garbage/$containerName
    if [ ! -e $DYSNOMIA_STATEDIR/garbage/$containerName/$componentName ]
    then
        mv $DYSNOMIA_STATEDIR/activated/$containerName/$componentName $DYSNOMIA_STATEDIR/garbage/$containerName/$componentName
    fi
}

# Environment variables:
#
# Unmarks a component as garbage so that it will be considered as no longer
# deployed.
#
# containerName: Name of the container in which the mutable component is hosted
# garbagePath: Path to the directory that stores which components have been marked as garbage

unmarkComponentAsGarbage()
{
    rm -f $DYSNOMIA_STATEDIR/garbage/$containerName/$componentName
}

# Determines the name of the last snapshot.
#
# Environment variables:
# generationsPath: Directory in which the generation symlinks are stored
# lastSnapshot: Will be set to the last snapshot or empty value if no snapshot generations exist

determineLastSnapshot()
{
    if [ -d $generationsPath ]
    then
        lastGeneration=$(ls $generationsPath | sort -n | tail -1)
        
        if [ "$lastGeneration" = "" ]
        then
            lastSnapshot=""
        else
            lastSnapshot=$(basename $(readlink $generationsPath/$lastGeneration))
        fi
    else
        lastSnapshot=""
    fi
}

# Compose the path in which snapshots of components are stored
#
# Environment variables:
# DYSNOMIA_STATEDIR: Path where Dysnomia stores state
# containerName: Name of the container in which the mutable component is hosted
# componentName: Name of the mutable component
# snapshotsPath: Will be set to the path in which snapshots are stored

composeSnapshotsPath()
{
    snapshotsPath=$DYSNOMIA_STATEDIR/snapshots/$containerName/$componentName
}

# Compose the path in which the generation symlinks of component snapshots are
# stored
#
# Environment variables:
# DYSNOMIA_STATEDIR: Path where Dysnomia stores state
# containerName: Name of the container in which the mutable component is hosted
# componentName: Name of the mutable component
# generationsPath: Will be set to the path in which generation symlinks are stored

composeGenerationsPath()
{
    generationsPath=$DYSNOMIA_STATEDIR/generations/$containerName/$componentName
}

# Compose the path in which the components names are stored that have become
# garbage
#
# Environment variables:
# DYSNOMIA_STATEDIR: Path where Dysnomia stores state
# containerName: Name of the container in which the mutable component is hosted
# componentName: Name of the mutable component
# garbagePath: Will be set to the path in which garbage flags are stored

composeGarbagePath()
{
    garbagePath=$DYSNOMIA_STATEDIR/garbage/$containerName/$componentName
}

# Creates a new generation symlink to a given snapshot.
#
# Parameters:
# $1: Name of a snapshot
#
# Environment variables:
# containerName: Name of the container in which the mutable component is hosted
# componentName: Name of the mutable component
# generationsPath: Path in which the generation symlinks are stored
# snapshotsPath: Path in which the snapshots are stored

createGenerationSymlink()
{
    if [ -d $generationsPath ]
    then
        lastGeneration=$(ls $generationsPath | sort -n | tail -1)
        
        if [ "$lastGeneration" = "" ]
        then
            lastGeneration=0
        fi
    else
        mkdir -p $generationsPath
        lastGeneration=0
    fi
    
    if [ "$lastGeneration" = "0" ] || [ "$(basename $(readlink $generationsPath/$lastGeneration))" != "$1" ] # Only create the generation symlink if the previous symlink refers to a different snapshot
    then
        newGeneration=$((lastGeneration+1))
        ln -s "../../../snapshots/$containerName/$componentName/$1" $generationsPath/$newGeneration
    fi
}

# Attempts to execute a command and retries it a given number of times if it
# fails.
#
# Parameters:
# $1: Command to execute
# $2: The amount of times to retry if te command fails

attemptSeveralTimes()
{
    local num=0
    while [ $num -lt $2 ]
    do
        if $1
        then
            break
        fi
        
        echo "Commmand failed, trying again in a second..." >&2
        sleep 1
        num=$((num + 1))
    done
    
    if [ $num -eq $2 ]
    then
        echo "Still does not work after $num attempts!" >&2
        false
    fi
}

# Removes a systemd job and its wanted dependencies
#
# Parameters:
# $1: Absolute path to the unit to remove
# $2: Path to the mutable component to activate

removeSystemdService()
{
    local jobsDir=$(dirname "$1")
    local jobName=$(basename "$1" .service)
    
    if [ -f $jobsDir/dysnomia.target ]
    then
        rm -f $jobsDir/dysnomia.target.wants/$jobName.service
        rmdir --ignore-fail-on-non-empty $jobsDir/dysnomia.target.wants
    fi
    
    rm -f "$1"
    
    if [ -f $2/etc/socket ]
    then
        rm -f $jobsDir/$jobName.socket
    fi
}

# Activates a systemd job and configures its wanted dependencies
#
# Parameters:
# $1: Absolute path to the unit to activate
# $2: Path to the mutable component to activate

activateSystemdService()
{
    local jobsDir=$(dirname "$1")
    local jobName=$(basename "$1" .service)
    
    addUserSettingsToSystemdConfig "$1"
    if [ -f $2/etc/systemd-config ]
    then
        cat $2/etc/systemd-config >> "$1"
    fi
    
    if [ -f $jobsDir/dysnomia.target ]
    then
        mkdir -p $jobsDir/dysnomia.target.wants
        ln -sf ../$jobName.service $jobsDir/dysnomia.target.wants/$jobName.service
    fi
    
    if [ -f $2/etc/socket ]
    then
        cp $2/etc/socket $jobsDir/$jobName.socket
        startUnit=$jobName.socket
    else
        startUnit=$jobName.service
    fi
    
    systemctl --system daemon-reload
    systemctl start $startUnit || (removeSystemdService $jobsDir/$jobName.service $2; removeUnprivilegedUserAndGroup; false)
}
